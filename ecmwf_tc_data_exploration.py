#!/usr/bin/env python3
"""
ECMWF Tropical Cyclone Track Data Visualization

This module provides individual visualization functions for tropical cyclone
track data extracted from ECMWF BUFR files. It creates focused plots showing
storm tracks, wind field structure, data availability, and wind radii analysis.

The visualizer works with CSV files generated by the ecmwf_tc_data_extractor module,
providing individual analysis plots for specific aspects of tropical cyclone data.

Data Requirements:
- Input: CSV file from ecmwf_tc_data_extractor module
- Required columns: storm_id, ensemble_member, forecast_step_hours, datetime,
  position_type, latitude, longitude, wind_speed_knots, wind_threshold_knots,
  bearing_degrees, max_radius_km, has_wind_radii

Processing Functions:
1. load_tc_data() - Load and validate CSV data from extractor
2. calculate_wind_radii_from_points() - Calculate wind radii from spatial distributions
3. create_track_visualization() - Create ensemble track plots
4. create_wind_field_visualization() - Visualize wind structure and radii
5. create_data_availability_visualization() - Assess data completeness and coverage
6. create_wind_radii_spatial_plot() - Plot wind radii by speed threshold
7. create_wind_radii_direction_plot() - Plot wind radii by cardinal direction

References:
- ECMWF Tropical Cyclone Data: https://essential.ecmwf.int/
- Hurricane Intensity Scale: https://www.nhc.noaa.gov/aboutsshws.php
"""

import os
import warnings
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Union

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib.patches import Circle
from matplotlib.collections import PatchCollection

# Suppress warnings for cleaner output
warnings.filterwarnings('ignore')

# Configuration
DEFAULT_OUTPUT_DIR = "tc_data"
DEFAULT_DPI = 300
DEFAULT_FIGSIZE = (16, 12)

# Hurricane category thresholds (knots)
HURRICANE_CATEGORIES = {
    34: 'TS',      # Tropical Storm
    64: 'Cat1',    # Category 1 Hurricane
    83: 'Cat2',    # Category 2 Hurricane
    96: 'Cat3',    # Category 3 Hurricane
    113: 'Cat4',   # Category 4 Hurricane
    137: 'Cat5'    # Category 5 Hurricane
}

# Wind threshold colors for visualization
WIND_THRESHOLD_COLORS = {
    35: 'yellow',   # ~34kt - Tropical Storm
    50: 'orange',   # ~50kt - Strong TS
    64: 'red'       # ~64kt - Hurricane
}

# Bearing direction mapping
BEARING_NAMES = {
    0: 'North',
    90: 'East', 
    180: 'South',
    270: 'West'
}

def load_tc_data(csv_file: str, verbose: bool = True) -> pd.DataFrame:
    """
    Load tropical cyclone data from CSV file generated by extractor.
    
    This function loads and validates the CSV data from the ecmwf_tc_data_extractor
    module, ensuring all required columns are present and data types are correct.
    
    Args:
        csv_file (str): Path to the CSV file from extractor
        verbose (bool): Whether to print detailed loading information
        
    Returns:
        pd.DataFrame: Loaded and validated tropical cyclone data
    """
    if not os.path.exists(csv_file):
        raise FileNotFoundError(f"CSV file not found: {csv_file}")

    # Load CSV data
    df = pd.read_csv(csv_file)
    df['datetime'] = pd.to_datetime(df['datetime'])
    
    if verbose:
        print(f"Total records loaded: {len(df)}")
        print(f"Columns in dataset: {len(df.columns)}")
    
    # Validate required columns
    required_columns = [
        'storm_id', 'ensemble_member', 'forecast_step_hours', 'datetime',
        'position_type', 'latitude', 'longitude', 'wind_speed_knots',
        'wind_threshold_knots', 'bearing_degrees', 'has_wind_radii'
    ]
    
    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        raise ValueError(f"Missing required columns: {missing_columns}")
    
    # Data quality summary
    if verbose:
        print(f"\nData quality summary:")
        for col in required_columns:
            non_null = df[col].count()
            print(f"  {col}: {non_null}/{len(df)} values ({100*non_null/len(df):.1f}%)")
    
    # Wind radii analysis
    wind_radii = df[df['has_wind_radii'] == True]
    if verbose:
        print(f"\nWind radii analysis:")
        print(f"  Records with wind radii flags: {len(wind_radii)}")
        print(f"  Records with coordinates: {wind_radii[['latitude', 'longitude']].dropna().shape[0]}")
        print(f"  Records with wind thresholds: {wind_radii['wind_threshold_knots'].count()}")
        print(f"  Records with bearings: {wind_radii['bearing_degrees'].count()}")
    
    return df

def calculate_wind_radii_from_points(df: pd.DataFrame, verbose: bool = True) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """
    Calculate wind radii by analyzing spatial distribution of wind points.
    
    This function calculates actual wind radii distances by finding the distance
    between wind radii points and their corresponding storm centers.
    
    Args:
        df (pd.DataFrame): Tropical cyclone data with wind radii points
        verbose (bool): Whether to print calculation progress
        
    Returns:
        Tuple[pd.DataFrame, pd.DataFrame]: 
            - Updated dataframe with calculated_radius_km column
            - DataFrame with detailed radius calculations
    """
    # Get storm centers and wind radii points
    storm_centers = df[df['position_type'] == 'storm_center'].dropna(subset=['latitude', 'longitude'])
    wind_points = df[df['has_wind_radii'] == True].dropna(subset=['latitude', 'longitude'])
    
    if storm_centers.empty or wind_points.empty:
        if verbose:
            print("Cannot calculate radii - missing storm centers or wind points")
        return df, pd.DataFrame()
    
    calculated_radii = []
    
    # For each wind radii point, find the nearest storm center and calculate distance
    for _, wind_point in wind_points.iterrows():
        # Find storm centers at the same forecast time and member (if possible)
        matching_centers = storm_centers[
            (storm_centers['forecast_step_hours'] == wind_point['forecast_step_hours']) &
            (storm_centers['ensemble_member'] == wind_point['ensemble_member'])
        ]
        
        if matching_centers.empty:
            # Fall back to any storm center at the same forecast time
            matching_centers = storm_centers[
                storm_centers['forecast_step_hours'] == wind_point['forecast_step_hours']
            ]
        
        if not matching_centers.empty:
            # Calculate distance to nearest center using Haversine formula
            center = matching_centers.iloc[0]
            
            # Haversine distance calculation
            lat1, lon1 = np.radians(center['latitude']), np.radians(center['longitude'])
            lat2, lon2 = np.radians(wind_point['latitude']), np.radians(wind_point['longitude'])
            
            dlat = lat2 - lat1
            dlon = lon2 - lon1
            a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
            c = 2 * np.arcsin(np.sqrt(a))
            distance_km = 6371 * c  # Earth's radius in km
            
            calculated_radii.append({
                'wind_point_index': wind_point.name,
                'storm_center_lat': center['latitude'],
                'storm_center_lon': center['longitude'],
                'wind_point_lat': wind_point['latitude'],
                'wind_point_lon': wind_point['longitude'],
                'calculated_radius_km': distance_km,
                'wind_threshold_knots': wind_point['wind_threshold_knots'],
                'bearing_degrees': wind_point['bearing_degrees'],
                'forecast_step_hours': wind_point['forecast_step_hours'],
                'ensemble_member': wind_point['ensemble_member']
            })
    
    if calculated_radii:
        radii_df = pd.DataFrame(calculated_radii)
        if verbose:
            print(f"Calculated radii for {len(radii_df)} wind points")
            print(f"Radius range: {radii_df['calculated_radius_km'].min():.1f} to {radii_df['calculated_radius_km'].max():.1f} km")
        
        # Add calculated radii back to original dataframe
        df = df.copy()
        df['calculated_radius_km'] = np.nan
        for _, row in radii_df.iterrows():
            idx = row['wind_point_index']
            df.loc[idx, 'calculated_radius_km'] = row['calculated_radius_km']
        
        return df, radii_df
    else:
        if verbose:
            print("No radii could be calculated")
        return df, pd.DataFrame()

def create_track_visualization(df: pd.DataFrame, output_filename: Optional[str] = None) -> plt.Figure:
    """
    Create ensemble track visualization showing storm paths with distinct forecast hour colors.
    
    This function creates a track plot showing individual ensemble member tracks
    with points colored by distinct forecast hour categories.
    
    Args:
        df (pd.DataFrame): Tropical cyclone data with track information
        output_filename (str, optional): Path to save the plot
        
    Returns:
        plt.Figure: The created matplotlib figure
    """
    # Filter for all track data (not just storm centers)
    all_track_data = df.dropna(subset=['latitude', 'longitude'])
    
    if all_track_data.empty:
        print("No track data found for track visualization")
        return None
    
    fig, ax = plt.subplots(figsize=DEFAULT_FIGSIZE)
    
    # Add simple basemap background
    ax.set_facecolor('lightblue')
    ax.grid(True, alpha=0.3, color='white', linewidth=0.5)
    
    
    # Define distinct colors for different forecast hour ranges
    def get_forecast_color(hour):
        if hour <= 24:
            return 'darkblue'    # 0-24h
        elif hour <= 48:
            return 'blue'        # 24-48h
        elif hour <= 72:
            return 'green'       # 48-72h
        elif hour <= 96:
            return 'orange'      # 72-96h
        elif hour <= 120:
            return 'red'         # 96-120h
        else:
            return 'purple'      # 120h+
    
    # Create legend elements
    legend_elements = [
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='darkblue', markersize=8, label='0-24h'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='blue', markersize=8, label='24-48h'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='green', markersize=8, label='48-72h'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='orange', markersize=8, label='72-96h'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='red', markersize=8, label='96-120h'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='purple', markersize=8, label='120h+')
    ]
    
    # Plot individual ensemble member tracks with distinct forecast hour colors
    members_plotted = []
    for member in sorted(all_track_data['ensemble_member'].unique())[:10]:
        member_data = all_track_data[all_track_data['ensemble_member'] == member].sort_values('forecast_step_hours')
        if len(member_data) > 1:
            # Plot line connecting all points
            ax.plot(member_data['longitude'], member_data['latitude'],
                   '-', alpha=0.6, linewidth=1.5, color='gray')
            
            # Plot points with distinct colors for each forecast hour range
            for _, point in member_data.iterrows():
                color = get_forecast_color(point['forecast_step_hours'])
                ax.scatter(point['longitude'], point['latitude'],
                          c=color, s=40, alpha=0.9, 
                          edgecolor='black', linewidth=0.8)
            
            members_plotted.append(member)
        elif len(member_data) == 1:
            # Single point - show as dot
            point = member_data.iloc[0]
            color = get_forecast_color(point['forecast_step_hours'])
            ax.scatter(point['longitude'], point['latitude'],
                      c=color, s=60, alpha=0.9, 
                      edgecolor='black', linewidth=0.8)
            members_plotted.append(member)
    
    # Add legend
    ax.legend(handles=legend_elements, loc='upper right', title='Forecast Hours')
    
    # Add member indication text
    members_text = f"Ensemble Members: {', '.join(map(str, sorted(members_plotted)))}"
    ax.text(0.02, 0.98, members_text, transform=ax.transAxes, fontsize=10,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
    
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_title(f'Hurricane {df.iloc[0]["storm_id"]} - Ensemble Track (Colored by Forecast Hour)')
    
    if output_filename:
        plt.savefig(output_filename, dpi=DEFAULT_DPI, bbox_inches='tight')
        print(f"Track visualization saved as: {output_filename}")
    
    return fig

def create_wind_field_visualization(df: pd.DataFrame, radii_df: Optional[pd.DataFrame] = None, 
                                  output_filename: Optional[str] = None) -> plt.Figure:
    """
    Create wind field structure visualization with wind radii.
    
    This function visualizes the wind field structure by plotting storm centers
    and wind radii data, showing the spatial extent of different wind speed thresholds.
    
    Args:
        df (pd.DataFrame): Tropical cyclone data
        radii_df (pd.DataFrame, optional): Calculated wind radii data
        output_filename (str, optional): Path to save the plot
        
    Returns:
        plt.Figure: The created matplotlib figure
    """
    # Filter data - use all track data for storm centers
    all_track_data = df.dropna(subset=['latitude', 'longitude'])
    wind_radii = df[df['has_wind_radii'] == True].dropna(subset=['latitude', 'longitude'])
    
    if all_track_data.empty:
        print("No track data found for wind field visualization")
        return None
    
    fig, ax = plt.subplots(figsize=DEFAULT_FIGSIZE)
    
    # Add simple ocean background
    ax.set_facecolor('lightblue')
    ax.grid(True, alpha=0.3, color='white', linewidth=0.5)
    
    # Plot storm centers with one color per ensemble member and connected tracks
    colors = plt.cm.tab10(np.linspace(0, 1, min(10, all_track_data['ensemble_member'].nunique())))
    members_plotted = []
    
    for i, member in enumerate(sorted(all_track_data['ensemble_member'].unique())[:10]):
        member_data = all_track_data[all_track_data['ensemble_member'] == member].sort_values('forecast_step_hours')
        if len(member_data) > 1:
            color = colors[i % len(colors)]
            
            # Plot connected line
            ax.plot(member_data['longitude'], member_data['latitude'],
                   '-', alpha=0.7, linewidth=1.5, color=color, label=f'Member {member}')
            
            # Plot smaller points
            ax.scatter(member_data['longitude'], member_data['latitude'],
                      c=[color], s=30, alpha=0.8, edgecolor='black', linewidth=0.5)
            
            members_plotted.append(member)
        elif len(member_data) == 1:
            # Single point
            color = colors[i % len(colors)]
            point = member_data.iloc[0]
            ax.scatter(point['longitude'], point['latitude'],
                      c=[color], s=50, alpha=0.8, edgecolor='black', linewidth=0.5, label=f'Member {member}')
            members_plotted.append(member)
    
    # Plot wind radii as directional sectors (wind swaths) if we have radius data
    if radii_df is not None and not radii_df.empty:
        print(f"  Drawing {len(radii_df)} directional wind swaths...")
        
        # Group by wind threshold for different colors
        for threshold, color in WIND_THRESHOLD_COLORS.items():
            threshold_radii = radii_df[abs(radii_df['wind_threshold_knots'] - threshold) < 5]
            
            for _, row in threshold_radii.iterrows():
                # Convert radius from km to degrees (rough approximation)
                radius_deg = row['calculated_radius_km'] / 111.0  # 1 degree ≈ 111 km
                
                # Create directional sector based on bearing
                bearing = row['bearing_degrees']
                center_lon = row['storm_center_lon']
                center_lat = row['storm_center_lat']
                
                # Define sector angles (90-degree sectors)
                if bearing == 0:  # North
                    theta1, theta2 = 315, 45  # -45 to +45 degrees
                elif bearing == 90:  # East
                    theta1, theta2 = 45, 135  # +45 to +135 degrees
                elif bearing == 180:  # South
                    theta1, theta2 = 135, 225  # +135 to +225 degrees
                elif bearing == 270:  # West
                    theta1, theta2 = 225, 315  # +225 to +315 degrees
                else:
                    continue  # Skip if bearing not recognized
                
                # Create sector (wedge) for wind swath
                from matplotlib.patches import Wedge
                wedge = Wedge((center_lon, center_lat), radius_deg, 
                            theta1, theta2, fill=True, color=color, alpha=0.3,
                            linewidth=1, linestyle='-')
                ax.add_patch(wedge)
    
    # Plot wind radii points
    for threshold, color in WIND_THRESHOLD_COLORS.items():
        subset = wind_radii[abs(wind_radii['wind_threshold_knots'] - threshold) < 5]
        if not subset.empty:
            ax.scatter(subset['longitude'], subset['latitude'],
                      c=color, s=30, alpha=0.8, edgecolor='black',
                      label=f'{threshold}kt winds')
    
    # Add member indication text
    members_text = f"Ensemble Members: {', '.join(map(str, sorted(members_plotted)))}"
    ax.text(0.02, 0.98, members_text, transform=ax.transAxes, fontsize=10,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
    
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_title(f'Hurricane {df.iloc[0]["storm_id"]} - Wind Field Structure')
    ax.grid(True, alpha=0.3)
    ax.legend()
    
    if output_filename:
        plt.savefig(output_filename, dpi=DEFAULT_DPI, bbox_inches='tight')
        print(f"Wind field visualization saved as: {output_filename}")
    
    return fig


def create_data_availability_visualization(df: pd.DataFrame, output_filename: Optional[str] = None) -> plt.Figure:
    """
    Create comprehensive data availability visualization.
    
    This function creates a multi-panel plot showing:
    1. Data availability by ensemble member and position type
    2. Forecast hour coverage by ensemble member
    3. Data completeness statistics
    
    Args:
        df (pd.DataFrame): Tropical cyclone data
        output_filename (str, optional): Path to save the plot
        
    Returns:
        plt.Figure: The created matplotlib figure
    """
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
    
    # Panel 1: Data availability by ensemble member and position type
    position_types = df['position_type'].unique()
    ensemble_members = sorted(df['ensemble_member'].unique())
    
    # Create availability matrix
    availability_data = []
    for member in ensemble_members:
        member_data = df[df['ensemble_member'] == member]
        row = []
        for pos_type in position_types:
            count = len(member_data[member_data['position_type'] == pos_type])
            row.append(count)
        availability_data.append(row)
    
    im1 = ax1.imshow(availability_data, cmap='YlOrRd', aspect='auto')
    ax1.set_xticks(range(len(position_types)))
    ax1.set_xticklabels(position_types, rotation=45, ha='right')
    ax1.set_yticks(range(0, len(ensemble_members), 5))
    ax1.set_yticklabels([ensemble_members[i] for i in range(0, len(ensemble_members), 5)])
    ax1.set_xlabel('Position Type')
    ax1.set_ylabel('Ensemble Member')
    ax1.set_title('Data Records per Member and Position Type')
    plt.colorbar(im1, ax=ax1, label='Number of Records')
    
    # Panel 2: Forecast hour coverage by ensemble member (only records with coordinates)
    forecast_hours = sorted(df['forecast_step_hours'].unique())
    coverage_data = []
    
    for member in ensemble_members:
        # Only count hours where member has actual coordinate data
        member_data = df[(df['ensemble_member'] == member) & df['latitude'].notna()]
        member_hours = set(member_data['forecast_step_hours'].unique())
        coverage = [1 if hour in member_hours else 0 for hour in forecast_hours]
        coverage_data.append(coverage)
    
    im2 = ax2.imshow(coverage_data, cmap='RdYlGn', aspect='auto', vmin=0, vmax=1)
    ax2.set_xticks(range(0, len(forecast_hours), 10))
    ax2.set_xticklabels([forecast_hours[i] for i in range(0, len(forecast_hours), 10)], rotation=45)
    ax2.set_yticks(range(0, len(ensemble_members), 5))
    ax2.set_yticklabels([ensemble_members[i] for i in range(0, len(ensemble_members), 5)])
    ax2.set_xlabel('Forecast Hour')
    ax2.set_ylabel('Ensemble Member')
    ax2.set_title('Forecast Hour Coverage by Member (Coordinates Only)')
    
    # Create discrete colorbar
    cbar = plt.colorbar(im2, ax=ax2, ticks=[0, 1])
    cbar.set_ticklabels(['No Data', 'Has Data'])
    cbar.set_label('Data Availability')
    
    # Panel 3: Data completeness statistics (only records with actual data)
    completeness_stats = []
    for pos_type in position_types:
        pos_data = df[df['position_type'] == pos_type]
        # Only count records that have at least some actual data (not just placeholders)
        records_with_any_data = len(pos_data.dropna(subset=['latitude', 'longitude', 'wind_speed_knots', 'pressure_pa'], how='all'))
        records_with_coords = len(pos_data.dropna(subset=['latitude', 'longitude']))
        records_with_wind = len(pos_data.dropna(subset=['wind_speed_knots']))
        records_with_pressure = len(pos_data.dropna(subset=['pressure_pa']))
        
        completeness_stats.append({
            'Position Type': pos_type,
            'Records with Data': records_with_any_data,
            'With Coordinates': records_with_coords,
            'With Wind Speed': records_with_wind,
            'With Pressure': records_with_pressure
        })
    
    stats_df = pd.DataFrame(completeness_stats)
    
    x = range(len(position_types))
    width = 0.2
    
    ax3.bar([i - width for i in x], stats_df['Records with Data'], width, label='Records with Data', alpha=0.8)
    ax3.bar(x, stats_df['With Coordinates'], width, label='With Coordinates', alpha=0.8)
    ax3.bar([i + width for i in x], stats_df['With Wind Speed'], width, label='With Wind Speed', alpha=0.8)
    
    ax3.set_xlabel('Position Type')
    ax3.set_ylabel('Number of Records')
    ax3.set_title('Data Completeness by Position Type')
    ax3.set_xticks(x)
    ax3.set_xticklabels(position_types, rotation=45, ha='right')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # Panel 4: Summary statistics
    ax4.axis('off')
    
    # Calculate summary statistics
    total_records = len(df)
    unique_members = df['ensemble_member'].nunique()
    unique_hours = df['forecast_step_hours'].nunique()
    records_with_coords = len(df.dropna(subset=['latitude', 'longitude']))
    records_with_wind = len(df.dropna(subset=['wind_speed_knots']))
    
    # Find members with most actual data (not just placeholders)
    members_with_data = df.dropna(subset=['latitude', 'longitude', 'wind_speed_knots', 'pressure_pa'], how='all')
    member_counts = members_with_data['ensemble_member'].value_counts()
    top_members = member_counts.head(5)
    
    summary_text = f"""
    DATA AVAILABILITY SUMMARY
    
    Total Records: {total_records:,} (including placeholders)
    Records with Actual Data: {len(members_with_data):,} ({100*len(members_with_data)/total_records:.1f}%)
    Ensemble Members: {unique_members}
    Forecast Hours: {unique_hours}
    
    DATA COMPLETENESS:
    Records with Coordinates: {records_with_coords:,} ({100*records_with_coords/total_records:.1f}%)
    Records with Wind Speed: {records_with_wind:,} ({100*records_with_wind/total_records:.1f}%)
    
    TOP 5 MEMBERS BY ACTUAL DATA COUNT:
    """
    
    for member, count in top_members.items():
        summary_text += f"    Member {member}: {count} records with data\n"
    
    summary_text += f"""
    FORECAST HOUR RANGE:
    {min(forecast_hours)}h to {max(forecast_hours)}h
    (Total span: {max(forecast_hours) - min(forecast_hours)} hours)
    """
    
    ax4.text(0.05, 0.95, summary_text, transform=ax4.transAxes, fontsize=10,
             verticalalignment='top', fontfamily='monospace',
             bbox=dict(boxstyle='round', facecolor='lightgray', alpha=0.8))
    
    plt.suptitle(f'Hurricane {df.iloc[0]["storm_id"]} - Data Availability Analysis', fontsize=16)
    plt.tight_layout()
    
    if output_filename:
        plt.savefig(output_filename, dpi=DEFAULT_DPI, bbox_inches='tight')
        print(f"Data availability visualization saved as: {output_filename}")
    
    return fig

def create_wind_radii_spatial_plot(df: pd.DataFrame, radii_df: Optional[pd.DataFrame] = None,
                                  output_filename: Optional[str] = None) -> plt.Figure:
    """
    Create wind radii spatial distribution plot showing wind speed thresholds.
    
    This function creates a scatter plot showing wind radii points colored by
    wind speed threshold, with the storm center marked as reference.
    
    Args:
        df (pd.DataFrame): Tropical cyclone data
        radii_df (pd.DataFrame, optional): Calculated wind radii data
        output_filename (str, optional): Path to save the plot
        
    Returns:
        plt.Figure: The created matplotlib figure
    """
    if radii_df is None or radii_df.empty:
        print("No wind radii data available for spatial plot")
        return None
    
    fig, ax = plt.subplots(figsize=(12, 8))
    
    # Add simple ocean background
    ax.set_facecolor('lightblue')
    ax.grid(True, alpha=0.3, color='white', linewidth=0.5)
    
    # Plot storm centers as reference
    storm_centers = df[df['position_type'] == 'storm_center'].dropna(subset=['latitude', 'longitude'])
    if not storm_centers.empty:
        # Use the first storm center as reference
        center_lat = storm_centers.iloc[0]['latitude']
        center_lon = storm_centers.iloc[0]['longitude']
        ax.scatter(center_lon, center_lat, c='black', s=100, marker='x', 
                  linewidth=3, label='Storm Center', zorder=10)
    
    # Plot wind radii points colored by threshold
    for threshold, color in [(35, 'yellow'), (50, 'orange'), (64, 'red')]:
        threshold_data = radii_df[abs(radii_df['wind_threshold_knots'] - threshold) < 5]
        if not threshold_data.empty:
            ax.scatter(threshold_data['wind_point_lon'], threshold_data['wind_point_lat'],
                      c=color, s=50, alpha=0.7, edgecolor='black', linewidth=0.5,
                      label=f'{threshold}kt winds')
    
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_title(f'Hurricane {df.iloc[0]["storm_id"]} - Wind Radii Spatial Distribution')
    ax.grid(True, alpha=0.3)
    ax.legend()
    
    # Set axis limits to show all wind radii points
    if not radii_df.empty:
        lon_min = radii_df['wind_point_lon'].min() - 0.5
        lon_max = radii_df['wind_point_lon'].max() + 0.5
        lat_min = radii_df['wind_point_lat'].min() - 0.5
        lat_max = radii_df['wind_point_lat'].max() + 0.5
        ax.set_xlim(lon_min, lon_max)
        ax.set_ylim(lat_min, lat_max)
    
    if output_filename:
        plt.savefig(output_filename, dpi=DEFAULT_DPI, bbox_inches='tight')
        print(f"Wind radii spatial plot saved as: {output_filename}")
    
    return fig

def create_wind_radii_direction_plot(df: pd.DataFrame, radii_df: Optional[pd.DataFrame] = None,
                                    output_filename: Optional[str] = None) -> plt.Figure:
    """
    Create wind radii spatial distribution plot showing wind directions.
    
    This function creates a scatter plot showing wind radii points colored by
    cardinal direction, with the storm center marked as reference.
    
    Args:
        df (pd.DataFrame): Tropical cyclone data
        radii_df (pd.DataFrame, optional): Calculated wind radii data
        output_filename (str, optional): Path to save the plot
        
    Returns:
        plt.Figure: The created matplotlib figure
    """
    if radii_df is None or radii_df.empty:
        print("No wind radii data available for direction plot")
        return None
    
    fig, ax = plt.subplots(figsize=(12, 8))
    
    # Add simple ocean background
    ax.set_facecolor('lightblue')
    ax.grid(True, alpha=0.3, color='white', linewidth=0.5)
    
    # Plot storm centers as reference
    storm_centers = df[df['position_type'] == 'storm_center'].dropna(subset=['latitude', 'longitude'])
    if not storm_centers.empty:
        # Use the first storm center as reference
        center_lat = storm_centers.iloc[0]['latitude']
        center_lon = storm_centers.iloc[0]['longitude']
        ax.scatter(center_lon, center_lat, c='black', s=100, marker='x', 
                  linewidth=3, label='Storm Center', zorder=10)
    
    # Plot wind radii points colored by direction
    bearings = [0, 90, 180, 270]  # N, E, S, W
    bearing_labels = ['North', 'East', 'South', 'West']
    bearing_colors = ['blue', 'green', 'red', 'purple']
    
    for bearing, label, color in zip(bearings, bearing_labels, bearing_colors):
        bearing_data = radii_df[radii_df['bearing_degrees'] == bearing]
        if not bearing_data.empty:
            # Add arrows at wind radii points pointing in their direction
            for _, point in bearing_data.iterrows():
                # Use wind radii point location as starting point
                start_lon = point['wind_point_lon']
                start_lat = point['wind_point_lat']
                
                # Calculate arrow end point based on bearing
                bearing_rad = np.radians(bearing)
                
                # Arrow length (in degrees)
                arrow_length = 0.2
                
                # Calculate end point
                end_lon = start_lon + arrow_length * np.sin(bearing_rad)
                end_lat = start_lat + arrow_length * np.cos(bearing_rad)
                
                # Draw arrow with direction color
                ax.annotate('', xy=(end_lon, end_lat), xytext=(start_lon, start_lat),
                           arrowprops=dict(arrowstyle='->', color=color, linewidth=2.5, alpha=0.8))
            
            # Add legend entry for this direction
            ax.scatter([], [], c=color, s=100, alpha=0.7, edgecolor='black', linewidth=0.5,
                      label=f'{label} ({bearing}°)')
    
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_title(f'Hurricane {df.iloc[0]["storm_id"]} - Wind Radii by Direction')
    ax.grid(True, alpha=0.3)
    ax.legend()
    
    # Set axis limits to show all wind radii points
    if not radii_df.empty:
        lon_min = radii_df['wind_point_lon'].min() - 0.5
        lon_max = radii_df['wind_point_lon'].max() + 0.5
        lat_min = radii_df['wind_point_lat'].min() - 0.5
        lat_max = radii_df['wind_point_lat'].max() + 0.5
        ax.set_xlim(lon_min, lon_max)
        ax.set_ylim(lat_min, lat_max)
    
    if output_filename:
        plt.savefig(output_filename, dpi=DEFAULT_DPI, bbox_inches='tight')
        print(f"Wind radii direction plot saved as: {output_filename}")
    
    return fig